import tkinter as tk
from tkinter import ttk
import serial
import threading
import time
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.animation import FuncAnimation
import numpy as np
from numpy import random
from PIL import Image, ImageTk
from reportlab.lib.pagesizes import A4
from fpdf import FPDF
from reportlab.pdfgen import canvas
from datetime import datetime

class ArduinoApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Menu Principal")

        self.dados_pacientes = []

    
        #Frames
        self.frame_menu = ttk.Frame(self.root, padding="20")
        self.frame_menu.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        self.frame_coleta = ttk.Frame(self.root, padding="20")

        #Configuração da interface
        self.configurar_menu_inicial()

        #Configuração inicial para Matplotlib e leitura de dados
        self.configurar_interface_coleta()

    def configurar_menu_inicial(self):
        label_bem_vindo = ttk.Label(self.frame_menu, text="Bem-vindo ao Sistema de Coleta de Dados da Quantificação de Tremores da Doença de Parkinson ", font=("Helvetica", 16))
        label_bem_vindo.grid(row=0, column=0, columnspan=2, pady=10)

        botao_iniciar_coleta = ttk.Button(self.frame_menu, text="Iniciar Coleta de Dados", command=self.mostrar_tela_coleta)
        botao_iniciar_coleta.grid(row=1, column=0, padx=5, pady=10)

        botao_configuracoes = ttk.Button(self.frame_menu, text="Pacientes", command=self.mostrar_cadastro_paciente)
        botao_configuracoes.grid(row=1, column=1, padx=5, pady=10)

        botao_sair = ttk.Button(self.frame_menu, text="Sair", command=self.root.quit)
        botao_sair.grid(row=5, column=0, columnspan=2, pady=20)
        
        self.carregar_logo()

    def carregar_logo(self):
        try:
            # Caminho correto da imagem
            imagem = Image.open(r"C:\Users\caiov\Desktop\parkinson\Parkison\ParkinsonData\Interface\upelogo.png")
            imagem = imagem.resize((150, 150), Image.LANCZOS)  # Use LANCZOS em vez de ANTIALIAS

            # Converte a imagem para o formato compatível com Tkinter
            self.logo = ImageTk.PhotoImage(imagem)

            # Adiciona a imagem ao menu
            label_logo = ttk.Label(self.frame_menu, image=self.logo)
            label_logo.grid(row=2, column=0, columnspan=5, pady=10)

        except Exception as e:
            print(f"Erro ao carregar a logo: {e}")

    def mostrar_tela_coleta(self):
    #Verifica se a conexão foi estabelecida corretamente
        #if  self.status_conexao.get() == "Pronto":
            self.frame_menu.grid_forget()  # Esconde o frame do menu
            self.frame_coleta.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))  # Mostra o frame de coleta
            self.status_conexao.set(" Arduino Pronto para coleta ✓ \n Sem problemas no Sistema ✓")  # Atualiza o status de conexão
            botao_voltar_menu = ttk.Button(self.frame_coleta, text="Voltar ao Menu", command=self.voltar_para_menu)
            botao_voltar_menu.grid(row=1, column=0, padx=10, pady=10, sticky=(tk.W, tk.E))
        #else:
           #tk.messagebox.showwarning("Aguardando Conexão", "Aguardando a conexão do Arduino. Por favor, verifique a conexão.")
    
    #Botão para voltar ao menu

    def voltar_para_menu(self):
        # Esconder o frame de coleta e voltar para o menu principal
        self.frame_coleta.grid_forget()  # Esconde o frame de coleta
        self.frame_menu.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))  # Mostra o frame do menu

    def mostrar_cadastro_paciente(self):
        #Abre uma nova janela para o cadastro de paciente
        janela_cadastro = tk.Toplevel(self.root)
        janela_cadastro.title("Cadastro de Paciente")

        #Campos para Nome, Sexo e Idade (já criados anteriormente)
        label_nome = ttk.Label(janela_cadastro, text="Nome do Paciente:")
        label_nome.grid(row=0, column=0, padx=10, pady=10)
        entrada_nome = ttk.Entry(janela_cadastro)
        entrada_nome.grid(row=0, column=1, padx=10, pady=10)

        label_sexo = ttk.Label(janela_cadastro, text="Sexo:")
        label_sexo.grid(row=1, column=0, padx=10, pady=10)
        combo_sexo = ttk.Combobox(janela_cadastro, values=["Masculino", "Feminino", "Outro"])
        combo_sexo.grid(row=1, column=1, padx=10, pady=10)

        label_idade = ttk.Label(janela_cadastro, text="Idade:")
        label_idade.grid(row=2, column=0, padx=10, pady=10)
        combo_idade = ttk.Combobox(janela_cadastro, values=["30 a 44", "45 a 59", "60 a 74", "75 a 84", "Maior que 85"])
        combo_idade.grid(row=2, column=1, padx=10, pady=10)

        #Nível de instrução
        label_instrucao = ttk.Label(janela_cadastro, text="Nível de Instrução:")
        label_instrucao.grid(row=3, column=0, padx=10, pady=10)
        combo_instrucao = ttk.Combobox(janela_cadastro, values=[
            "Sem instrução", "Fundamental incompleto", "Fundamental completo e médio incompleto",
            "Médio completo e superior incompleto", "Superior completo", "Não definido"
        ])
        combo_instrucao.grid(row=3, column=1, padx=10, pady=10)

        #Sintomas apresentados - Sintomas motores
        label_sintomas_motor = ttk.Label(janela_cadastro, text="Sintomas Motores:")
        label_sintomas_motor.grid(row=4, column=0, padx=10, pady=10)
        motor_frame = tk.Frame(janela_cadastro)
        motor_frame.grid(row=4, column=1, padx=10, pady=10)
        sintomas_motor = ["Tremor", "Rigidez", "Bradicinesia", "Instabilidade postural", "Marcha festinante",
                        "Alterações na fala", "Micrografia"]
        motor_vars = [tk.BooleanVar() for _ in sintomas_motor]
        for i, sintoma in enumerate(sintomas_motor):
            cb = tk.Checkbutton(motor_frame, text=sintoma, variable=motor_vars[i])
            cb.pack(anchor='w')

        #Sintomas apresentados - Sintomas não motores
        label_sintomas_nao_motor = ttk.Label(janela_cadastro, text="Sintomas Não Motores:")
        label_sintomas_nao_motor.grid(row=5, column=0, padx=10, pady=10)
        nao_motor_frame = tk.Frame(janela_cadastro)
        nao_motor_frame.grid(row=5, column=1, padx=10, pady=10)
        sintomas_nao_motor = ["Depressão", "Ansiedade", "Insônia", "Constipação", "Fadiga",
                            "Problemas de memória e cognição"]
        nao_motor_vars = [tk.BooleanVar() for _ in sintomas_nao_motor]
        for i, sintoma in enumerate(sintomas_nao_motor):
            cb = tk.Checkbutton(nao_motor_frame, text=sintoma, variable=nao_motor_vars[i])
            cb.pack(anchor='w')

        #Tempo de diagnóstico
        label_diagnostico = ttk.Label(janela_cadastro, text="Tempo de Diagnóstico:")
        label_diagnostico.grid(row=6, column=0, padx=10, pady=10)
        combo_diagnostico = ttk.Combobox(janela_cadastro, values=["0 a 3 anos", "5 a 10 anos", "Mais de 10 anos"])
        combo_diagnostico.grid(row=6, column=1, padx=10, pady=10)

        #Tratamento medicamentoso
        label_tratamento = ttk.Label(janela_cadastro, text="Tratamento Medicamentoso:")
        label_tratamento.grid(row=7, column=0, padx=10, pady=10)
        combo_tratamento = ttk.Combobox(janela_cadastro, values=["Sim", "Não"])
        combo_tratamento.grid(row=7, column=1, padx=10, pady=10)

        #Nome da medicação (se tratamento for "Sim")
        label_medicacao = ttk.Label(janela_cadastro, text="Qual medicação?")
        entrada_medicacao = ttk.Entry(janela_cadastro)
        label_medicacao.grid(row=8, column=0, padx=10, pady=10)
        entrada_medicacao.grid(row=8, column=1, padx=10, pady=10)

        #Terapia de reabilitação
        label_terapia = ttk.Label(janela_cadastro, text="Terapia de Reabilitação:")
        label_terapia.grid(row=9, column=0, padx=10, pady=10)
        combo_terapia = ttk.Combobox(janela_cadastro, values=["Sim", "Não"])
        combo_terapia.grid(row=9, column=1, padx=10, pady=10)

        #Tipo de Terapia
        label_tipo_terapia = ttk.Label(janela_cadastro, text="Tipo de Terapia:")
        label_tipo_terapia.grid(row=10, column=0, padx=10, pady=10)
        terapia_frame = tk.Frame(janela_cadastro)
        terapia_frame.grid(row=10, column=1, padx=10, pady=10)
        tipo_terapia = ["Fisioterapia", "Terapia Ocupacional", "Fonoaudiologia"]
        terapia_vars = [tk.BooleanVar() for _ in tipo_terapia]
        for i, tipo in enumerate(tipo_terapia):
            cb = tk.Checkbutton(terapia_frame, text=tipo, variable=terapia_vars[i])
            cb.pack(anchor='w')

        # Botão de salvar os dados do paciente
        botao_salvar_paciente = ttk.Button(janela_cadastro, text="Salvar Paciente", 
                                        command=lambda: self.salvar_paciente(entrada_nome.get(), combo_sexo.get(),
                                                                                combo_idade.get(), combo_instrucao.get(),
                                                                                motor_vars, nao_motor_vars, 
                                                                                combo_diagnostico.get(), combo_tratamento.get(),
                                                                                entrada_medicacao.get(), combo_terapia.get(), 
                                                                                terapia_vars, janela_cadastro))
        botao_salvar_paciente.grid(row=11, column=0, columnspan=2, pady=10)
    
    def salvar_paciente(self, nome, sexo, idade, instrucao, motor_vars, nao_motor_vars, diagnostico, tratamento, medicacao, terapia, terapia_vars, janela_cadastro):
        #Obter os sintomas motores selecionados
        sintomas_motor_selecionados = [sintoma for sintoma, var in zip(
            ["Tremor", "Rigidez", "Bradicinesia", "Instabilidade postural", "Marcha festinante", "Alterações na fala", "Micrografia"], motor_vars) if var.get()]
        
        #Obter os sintomas não motores selecionados
        sintomas_nao_motor_selecionados = [sintoma for sintoma, var in zip(
            ["Depressão", "Ansiedade", "Insônia", "Constipação", "Fadiga", "Problemas de memória e cognição"], nao_motor_vars) if var.get()]
        
        #Obter os tipos de terapia selecionados
        terapias_selecionadas = [tipo for tipo, var in zip(
            ["Fisioterapia", "Terapia Ocupacional", "Fonoaudiologia"], terapia_vars) if var.get()]
        
        #Validação básica de campos obrigatórios
        if not nome or not sexo or not idade or not instrucao or not diagnostico or not tratamento or (tratamento == "Sim" and not medicacao) or not terapia:
            tk.messagebox.showerror("Erro", "Por favor, preencha todos os campos obrigatórios.")
            return
        
        #Criar uma string com todos os dados coletados
        paciente = (
            f"Nome: {nome}\n"
            f"Sexo: {sexo}\n"
            f"Idade: {idade}\n"
            f"Nível de Instrução: {instrucao}\n"
            f"Sintomas Motores: {', '.join(sintomas_motor_selecionados) if sintomas_motor_selecionados else 'Nenhum'}\n"
            f"Sintomas Não Motores: {', '.join(sintomas_nao_motor_selecionados) if sintomas_nao_motor_selecionados else 'Nenhum'}\n"
            f"Tempo de Diagnóstico: {diagnostico}\n"
            f"Tratamento Medicamentoso: {tratamento}\n"
            f"Medicação: {medicacao if tratamento == 'Sim' else 'Não se aplica'}\n"
            f"Terapia de Reabilitação: {terapia}\n"
            f"Tipos de Terapia: {', '.join(terapias_selecionadas) if terapias_selecionadas else 'Nenhum'}"
        )

        self.dados_pacientes.append(paciente)

        #Exibir uma mensagem de confirmação com os dados do paciente
        tk.messagebox.showinfo("Paciente Cadastrado", f"Paciente cadastrado com sucesso!\n\n{paciente}")
        
        #Fechar a janela de cadastro após salvar os dados
        janela_cadastro.destroy()

    def configurar_interface_coleta(self):
        self.gravando = False
        self.status_conexao = tk.StringVar(value=" Desconectado - Erro na conexão do Arduino X")

        self.porta_serial = 'COM5'
        self.baud_rate = 9600
        self.timeout = 0.05

        sns.set(style="whitegrid")
        self.fig, (self.ax1, self.ax2, self.ax3) = plt.subplots(3, 1, figsize=(8, 8))
        plt.subplots_adjust(hspace=0.5)

        self.leitura1 = []
        self.leitura2 = []
        self.leitura3 = []

        self.interp_leitura1 = []
        self.interp_leitura2 = []
        self.interp_leitura3 = []

        frame_controles = ttk.Frame(self.frame_coleta, padding="10")
        frame_controles.grid(row=0, column=0, sticky=(tk.W, tk.E))

        botao_iniciar = ttk.Button(frame_controles, text="Iniciar Gravação", command=self.iniciar_gravacao)
        botao_iniciar.grid(row=0, column=0, padx=5, pady=5)

        botao_parar = ttk.Button(frame_controles, text="Parar Gravação", command=self.parar_gravacao)
        botao_parar.grid(row=0, column=1, padx=5, pady=5)

        status_label = ttk.Label(frame_controles, text="Status da Conexão:")
        status_label.grid(row=1, column=0, padx=5, pady=5, sticky=tk.E)

        #Botão para gerar o relatório PDF
        botao_relatorio = ttk.Button(frame_controles, text="Gerar Relatório", command=self.gerar_relatorio_pacientes)
        botao_relatorio.grid(row=0, column=2, padx=5, pady=5)  # Posicione o botão conforme necessário

        status_value = ttk.Label(frame_controles, textvariable=self.status_conexao)
        status_value.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)

        #Embedding Matplotlib figure into Tkinter
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.frame_coleta)
        self.canvas.get_tk_widget().grid(row=2, column=0, columnspan=2)

        self.anim = FuncAnimation(self.fig, self.atualizar_grafico, interval=200, cache_frame_data=False)

    def configurar_conexao_serial(self):
        try:
            self.ser = serial.Serial(self.porta_serial, self.baud_rate, timeout=self.timeout)
            time.sleep(2)
            self.status_conexao.set("Pronto")
        except serial.SerialException:
            self.status_conexao.set("Erro de Conexão")
            tk.messagebox.showerror("Erro", "Não foi possível conectar ao Arduino.")
            

    def ler_dados_arduino(self):
        if self.ser.is_open:
            linha = self.ser.readline().decode('utf-8').strip()
            return linha
        else:
            return None

    def atualizar_grafico(self, frame):
        self.ax1.clear()
        self.ax2.clear()
        self.ax3.clear()

        self.ax1.plot(self.interp_leitura1, label='Leitura 1', color='r')
        self.ax2.plot(self.interp_leitura2, label='Leitura 2', color='g')
        self.ax3.plot(self.interp_leitura3, label='Leitura 3', color='b')

        self.ax1.set_ylim(bottom=0, top=10000)
        self.ax2.set_ylim(bottom=0, top=10000)
        self.ax3.set_ylim(bottom=0, top=10000)

        self.ax1.set_xlabel("Dados coletados a cada 100 amostras interpoladas")
        self.ax1.set_ylabel("Pressão em Pascal (Pa)")
        self.ax2.set_xlabel("Dados coletados a cada 100 amostras interpoladas")
        self.ax2.set_ylabel("Pressão em Pascal (Pa)")
        self.ax3.set_xlabel("Dados coletados a cada 100 amostras interpoladas")
        self.ax3.set_ylabel("Pressão em Pascal (Pa)")

        self.ax1.legend(loc='upper right')
        self.ax2.legend(loc='upper right')
        self.ax3.legend(loc='upper right')

        if self.leitura1:
            self.ax1.text(0.02, 0.95, f'Leitura 1: {self.leitura1[-1]:.2f}', transform=self.ax1.transAxes, verticalalignment='top')
        if self.leitura2:
            self.ax2.text(0.02, 0.95, f'Leitura 2: {self.leitura2[-1]:.2f}', transform=self.ax2.transAxes, verticalalignment='top')
        if self.leitura3:
            self.ax3.text(0.02, 0.95, f'Leitura 3: {self.leitura3[-1]:.2f}', transform=self.ax3.transAxes, verticalalignment='top')

    def iniciar_gravacao(self):
        #Configuração da conexão serial
        self.configurar_conexao_serial()
        self.gravando = True
        self.status_conexao.set("Esperando início da gravação")
        threading.Thread(target=self.receber_dados).start()

    def parar_gravacao(self):
        self.gravando = False
        self.status_conexao.set("Gravação Parada")

    def receber_dados(self):
        if self.gravando:
            dados = self.ler_dados_arduino()
            if dados:
                try:
                    valores = list(map(float, dados.split('\t')))
                    if len(valores) == 3:
                        self.leitura1.append(valores[0])
                        self.leitura2.append(valores[1])
                        self.leitura3.append(valores[2])

                        if len(self.leitura1) > 100:
                            self.leitura1.pop(0)
                            self.leitura2.pop(0)
                            self.leitura3.pop(0)

                        self.interp_leitura1 = np.interp(np.linspace(0, len(self.leitura1) - 1, 500), np.arange(len(self.leitura1)), self.leitura1)
                        self.interp_leitura2 = np.interp(np.linspace(0, len(self.leitura2) - 1, 500), np.arange(len(self.leitura2)), self.leitura2)
                        self.interp_leitura3 = np.interp(np.linspace(0, len(self.leitura3) - 1, 500), np.arange(len(self.leitura3)), self.leitura3)

                except ValueError:
                    pass

            self.root.after(100, self.receber_dados)

    def fechar_conexao(self):
        self.gravando = False
        if hasattr(self, 'ser'):
            self.ser.close()
        self.root.destroy()

    def gerar_relatorio_pacientes(self):
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", size=12)

        pdf.cell(200, 10, txt="Relatório de Pacientes com Parkinson", ln=True, align="C")
        pdf.cell(200, 10, txt="Data: 2024-10-31", ln=True, align="C")

        for paciente in self.dados_pacientes:
            pdf.ln(10)
            pdf.cell(200, 10, txt=f"Nome: {paciente['nome']}", ln=True)
            pdf.cell(200, 10, txt=f"Sexo: {paciente['sexo']}", ln=True)
            pdf.cell(200, 10, txt=f"Idade: {paciente['idade']}", ln=True)
            pdf.cell(200, 10, txt=f"Nível de Instrução: {paciente['instrucao']}", ln=True)
            
            pdf.cell(200, 10, txt="Sintomas Motores:", ln=True)
            pdf.cell(200, 10, txt=", ".join(paciente['sintomas_motor']) if paciente['sintomas_motor'] else "Nenhum", ln=True)
            
            pdf.cell(200, 10, txt="Sintomas Não Motores:", ln=True)
            pdf.cell(200, 10, txt=", ".join(paciente['sintomas_nao_motor']) if paciente['sintomas_nao_motor'] else "Nenhum", ln=True)
            
            pdf.cell(200, 10, txt=f"Tempo de Diagnóstico: {paciente['diagnostico']}", ln=True)
            pdf.cell(200, 10, txt=f"Tratamento Medicamentoso: {paciente['tratamento']}", ln=True)
            pdf.cell(200, 10, txt=f"Medicação: {paciente['medicacao']}", ln=True)
            
            pdf.cell(200, 10, txt=f"Terapia de Reabilitação: {paciente['terapia']}", ln=True)
            pdf.cell(200, 10, txt="Tipos de Terapia:", ln=True)
            pdf.cell(200, 10, txt=", ".join(paciente['terapias_selecionadas']) if paciente['terapias_selecionadas'] else "Nenhum", ln=True)
            
            # Exemplo de Data de Coleta (se existir)
            if "data_coleta" in paciente:
                pdf.cell(200, 10, txt=f"Data da Coleta: {paciente['data_coleta']}", ln=True)
            
            # Exemplo de Medidas Coletadas (se existir)
            if "medidas" in paciente:
                pdf.cell(200, 10, txt="Medidas Coletadas:", ln=True)
                for medida in paciente["medidas"]:
                    pdf.cell(200, 10, txt=f"{medida:.2f}", ln=True)
            
            pdf.ln(10)  # espaço entre registros de pacientes

        # Salva o PDF com um nome especificado
        pdf.output("relatorio_pacientes.pdf")
        print("Relatório gerado com sucesso!")


#Inicializa a interface
if __name__ == "__main__":
    root = tk.Tk()
    app = ArduinoApp(root)
    root.protocol("WM_DELETE_WINDOW", app.fechar_conexao)
    root.mainloop()